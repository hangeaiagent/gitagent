import { DeploymentLog } from '../types/deployment';

export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  SUCCESS = 'success',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

export interface LogEntry {
  id: string;
  timestamp: Date;
  level: LogLevel;
  message: string;
  details?: string;
  agentName?: string;
  category?: string;
  metadata?: Record<string, any>;
  source: 'frontend' | 'backend' | 'ssh';
}

export interface LoggerConfig {
  enableConsole: boolean;
  enableRemote: boolean;
  enableStorage: boolean;
  maxLogEntries: number;
  logLevel: LogLevel;
  remoteEndpoint?: string;
}

export class LoggerService {
  private config: LoggerConfig;
  private logs: LogEntry[] = [];
  private listeners: ((log: LogEntry) => void)[] = [];

  constructor(config: Partial<LoggerConfig> = {}) {
    this.config = {
      enableConsole: true,
      enableRemote: true,
      enableStorage: true,
      maxLogEntries: 1000,
      logLevel: LogLevel.INFO,
      ...config
    };
  }

  /**
   * ËÆ∞ÂΩïÊó•Âøó
   */
  log(
    level: LogLevel,
    message: string,
    details?: string,
    agentName?: string,
    category?: string,
    metadata?: Record<string, any>
  ): void {
    const logEntry: LogEntry = {
      id: this.generateId(),
      timestamp: new Date(),
      level,
      message,
      details,
      agentName,
      category,
      metadata,
      source: 'frontend'
    };

    this.addLogEntry(logEntry);
  }

  /**
   * SSHÊâßË°åÊó•Âøó
   */
  logSSHExecution(
    command: string,
    result: {
      success: boolean;
      stdout: string;
      stderr: string;
      exitCode: number;
      executionTime: number;
    },
    host: string,
    username: string
  ): void {
    const level = result.success ? LogLevel.SUCCESS : LogLevel.ERROR;
    const message = result.success 
      ? `‚úÖ SSHÂëΩ‰ª§ÊâßË°åÊàêÂäü: ${command}`
      : `‚ùå SSHÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: ${command}`;

    const details = result.success
      ? `ËæìÂá∫: ${result.stdout.slice(0, 200)}${result.stdout.length > 200 ? '...' : ''}`
      : `ÈîôËØØ: ${result.stderr}`;

    this.addLogEntry({
      id: this.generateId(),
      timestamp: new Date(),
      level,
      message,
      details,
      agentName: 'SSHExecutor',
      category: 'ssh_execution',
      metadata: {
        command,
        host,
        username,
        exitCode: result.exitCode,
        executionTime: result.executionTime,
        stdout: result.stdout,
        stderr: result.stderr
      },
      source: 'ssh'
    });
  }

  /**
   * ËøûÊé•Êó•Âøó
   */
  logConnection(
    type: 'connect' | 'disconnect' | 'error',
    host: string,
    username: string,
    port: number,
    details?: string
  ): void {
    const levelMap = {
      connect: LogLevel.SUCCESS,
      disconnect: LogLevel.INFO,
      error: LogLevel.ERROR
    };

    const messageMap = {
      connect: `üîó SSHËøûÊé•ÊàêÂäü: ${username}@${host}:${port}`,
      disconnect: `üîå SSHËøûÊé•Êñ≠ÂºÄ: ${username}@${host}:${port}`,
      error: `üí• SSHËøûÊé•Â§±Ë¥•: ${username}@${host}:${port}`
    };

    this.addLogEntry({
      id: this.generateId(),
      timestamp: new Date(),
      level: levelMap[type],
      message: messageMap[type],
      details,
      agentName: 'ConnectionManager',
      category: 'connection',
      metadata: {
        host,
        username,
        port,
        type
      },
      source: 'backend'
    });
  }

  /**
   * ÈÉ®ÁΩ≤Ê≠•È™§Êó•Âøó
   */
  logDeploymentStep(
    stepName: string,
    status: 'start' | 'progress' | 'success' | 'error',
    details?: string,
    progress?: number
  ): void {
    const levelMap = {
      start: LogLevel.INFO,
      progress: LogLevel.INFO,
      success: LogLevel.SUCCESS,
      error: LogLevel.ERROR
    };

    const iconMap = {
      start: 'üöÄ',
      progress: '‚è≥',
      success: '‚úÖ',
      error: '‚ùå'
    };

    const message = `${iconMap[status]} ${stepName}`;

    this.addLogEntry({
      id: this.generateId(),
      timestamp: new Date(),
      level: levelMap[status],
      message,
      details,
      agentName: 'DeploymentManager',
      category: 'deployment',
      metadata: {
        stepName,
        status,
        progress
      },
      source: 'frontend'
    });
  }

  /**
   * Ê∑ªÂä†Êó•ÂøóÊù°ÁõÆ
   */
  private addLogEntry(logEntry: LogEntry): void {
    // Ê£ÄÊü•Êó•ÂøóÁ∫ßÂà´
    if (!this.shouldLog(logEntry.level)) {
      return;
    }

    // Ê∑ªÂä†Âà∞ÂÜÖÂ≠òÂ≠òÂÇ®
    this.logs.push(logEntry);

    // ÈôêÂà∂Êó•ÂøóÊï∞Èáè
    if (this.logs.length > this.config.maxLogEntries) {
      this.logs.shift();
    }

    // ÊéßÂà∂Âè∞ËæìÂá∫
    if (this.config.enableConsole) {
      this.logToConsole(logEntry);
    }

    // Êú¨Âú∞Â≠òÂÇ®
    if (this.config.enableStorage) {
      this.logToStorage(logEntry);
    }

    // ËøúÁ®ãÂèëÈÄÅ
    if (this.config.enableRemote && this.config.remoteEndpoint) {
      this.logToRemote(logEntry);
    }

    // ÈÄöÁü•ÁõëÂê¨Âô®
    this.listeners.forEach(listener => listener(logEntry));
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ËÆ∞ÂΩïËØ•Á∫ßÂà´ÁöÑÊó•Âøó
   */
  private shouldLog(level: LogLevel): boolean {
    const levelOrder = [
      LogLevel.DEBUG,
      LogLevel.INFO,
      LogLevel.SUCCESS,
      LogLevel.WARNING,
      LogLevel.ERROR,
      LogLevel.CRITICAL
    ];

    const currentLevelIndex = levelOrder.indexOf(this.config.logLevel);
    const logLevelIndex = levelOrder.indexOf(level);

    return logLevelIndex >= currentLevelIndex;
  }

  /**
   * ÊéßÂà∂Âè∞ËæìÂá∫
   */
  private logToConsole(logEntry: LogEntry): void {
    const prefix = `[${logEntry.timestamp.toLocaleTimeString()}] [${logEntry.level.toUpperCase()}]`;
    const message = `${prefix} ${logEntry.message}`;

    switch (logEntry.level) {
      case LogLevel.DEBUG:
        console.debug(message, logEntry.details);
        break;
      case LogLevel.INFO:
        console.info(message, logEntry.details);
        break;
      case LogLevel.SUCCESS:
        console.log(`%c${message}`, 'color: green', logEntry.details);
        break;
      case LogLevel.WARNING:
        console.warn(message, logEntry.details);
        break;
      case LogLevel.ERROR:
      case LogLevel.CRITICAL:
        console.error(message, logEntry.details);
        break;
    }
  }

  /**
   * Êú¨Âú∞Â≠òÂÇ®
   */
  private logToStorage(logEntry: LogEntry): void {
    try {
      const storageKey = 'gitagent_logs';
      const storedLogs = localStorage.getItem(storageKey);
      const logs = storedLogs ? JSON.parse(storedLogs) : [];
      
      logs.push({
        ...logEntry,
        timestamp: logEntry.timestamp.toISOString()
      });

      // ÈôêÂà∂Â≠òÂÇ®Êï∞Èáè
      if (logs.length > 500) {
        logs.splice(0, logs.length - 500);
      }

      localStorage.setItem(storageKey, JSON.stringify(logs));
    } catch (error) {
      console.error('Êó•ÂøóÂ≠òÂÇ®Â§±Ë¥•:', error);
    }
  }

  /**
   * ËøúÁ®ãÂèëÈÄÅ
   */
  private async logToRemote(logEntry: LogEntry): Promise<void> {
    try {
      if (!this.config.remoteEndpoint) return;

      await fetch(this.config.remoteEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...logEntry,
          timestamp: logEntry.timestamp.toISOString()
        })
      });
    } catch (error) {
      console.error('ËøúÁ®ãÊó•ÂøóÂèëÈÄÅÂ§±Ë¥•:', error);
    }
  }

  /**
   * Ê∑ªÂä†Êó•ÂøóÁõëÂê¨Âô®
   */
  addListener(listener: (log: LogEntry) => void): void {
    this.listeners.push(listener);
  }

  /**
   * ÁßªÈô§Êó•ÂøóÁõëÂê¨Âô®
   */
  removeListener(listener: (log: LogEntry) => void): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }

  /**
   * Ëé∑ÂèñÊâÄÊúâÊó•Âøó
   */
  getAllLogs(): LogEntry[] {
    return [...this.logs];
  }

  /**
   * ÊåâÁ±ªÂà´Ëé∑ÂèñÊó•Âøó
   */
  getLogsByCategory(category: string): LogEntry[] {
    return this.logs.filter(log => log.category === category);
  }

  /**
   * ÊåâÁ∫ßÂà´Ëé∑ÂèñÊó•Âøó
   */
  getLogsByLevel(level: LogLevel): LogEntry[] {
    return this.logs.filter(log => log.level === level);
  }

  /**
   * ÊåâÊó∂Èó¥ËåÉÂõ¥Ëé∑ÂèñÊó•Âøó
   */
  getLogsByTimeRange(start: Date, end: Date): LogEntry[] {
    return this.logs.filter(log => 
      log.timestamp >= start && log.timestamp <= end
    );
  }

  /**
   * Ê∏ÖÁ©∫Êó•Âøó
   */
  clearLogs(): void {
    this.logs = [];
    localStorage.removeItem('gitagent_logs');
  }

  /**
   * ÂØºÂá∫Êó•Âøó
   */
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * ËΩ¨Êç¢‰∏∫DeploymentLogÊ†ºÂºè
   */
  toDeploymentLog(logEntry: LogEntry): DeploymentLog {
    return {
      id: logEntry.id,
      timestamp: logEntry.timestamp,
      level: logEntry.level as any,
      message: logEntry.message,
      details: logEntry.details,
      agentName: logEntry.agentName
    };
  }

  /**
   * ÁîüÊàêÂîØ‰∏ÄID
   */
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ÂÖ®Â±ÄÊó•ÂøóÊúçÂä°ÂÆû‰æã
export const logger = new LoggerService({
  enableConsole: true,
  enableRemote: true,
  enableStorage: true,
  maxLogEntries: 1000,
  logLevel: LogLevel.INFO,
  remoteEndpoint: 'http://localhost:3000/api/logs'
});

// ‰æøÊç∑ÊñπÊ≥ï
export const logInfo = (message: string, details?: string, agentName?: string) => 
  logger.log(LogLevel.INFO, message, details, agentName);

export const logSuccess = (message: string, details?: string, agentName?: string) => 
  logger.log(LogLevel.SUCCESS, message, details, agentName);

export const logWarning = (message: string, details?: string, agentName?: string) => 
  logger.log(LogLevel.WARNING, message, details, agentName);

export const logError = (message: string, details?: string, agentName?: string) => 
  logger.log(LogLevel.ERROR, message, details, agentName);

export const logSSH = (command: string, result: any, host: string, username: string) =>
  logger.logSSHExecution(command, result, host, username);

export const logConnection = (type: 'connect' | 'disconnect' | 'error', host: string, username: string, port: number, details?: string) =>
  logger.logConnection(type, host, username, port, details);

export const logDeployment = (stepName: string, status: 'start' | 'progress' | 'success' | 'error', details?: string, progress?: number) =>
  logger.logDeploymentStep(stepName, status, details, progress); 